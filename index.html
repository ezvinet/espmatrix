<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Dual 8x8 LED Matrix Controller with ESP8266</title>
<style>
  body { font-family: Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background: #fafafa; }
  h1 { text-align: center; color: #222; }
  .matrix-container { display: flex; justify-content: space-around; margin: 20px 0; }
  canvas { border: 1px solid #aaa; display: block; margin: 10px auto; cursor: crosshair; background: #111; }
  .controls, .frameList, .device { background: white; padding: 15px; border-radius: 8px; margin: 15px 0; box-shadow: 0 0 8px #ddd; }
  button { margin: 5px 3px 5px 0; padding: 6px 12px; cursor: pointer; border: none; border-radius: 4px; background: #007bff; color: white; font-weight: 600; }
  button:hover { background: #0056b3; }
  input[type=color] { width: 50px; height: 30px; vertical-align: middle; border-radius: 4px; border: 1px solid #ccc; }
  input[type=number], input[type=text] { padding: 6px; width: 80px; border-radius: 4px; border: 1px solid #ccc; }
  label { margin-right: 10px; font-weight: 600; }
  #frames { list-style: none; padding-left: 0; max-height: 180px; overflow-y: auto; }
  #frames li { background: #f5f5f5; margin-bottom: 5px; padding: 8px; border-radius: 5px; display: flex; justify-content: space-between; align-items: center; font-family: monospace; }
  #frames li span { flex-grow: 1; }
  #status { text-align: center; padding: 10px; font-weight: bold; background: #eee; border-radius: 5px; margin-top: 15px; color: #333; }
  .grid-buttons { text-align: center; margin-top: 10px; }
  select { padding: 5px; border-radius: 4px; border: 1px solid #ccc; }
  .device-control { display: flex; justify-content: space-between; margin-bottom: 10px; }
  .device-control > div { flex: 1; padding: 0 10px; }
</style>
</head>
<body>

<h1>Dual 8x8 LED Matrix Controller for ESP8266</h1>

<div class="controls">
  <label>Color: <input type="color" id="colorPicker" value="#ff0000"></label>
  <button id="clearBtn">Clear</button>
  <button id="randomBtn">Random</button>
  <button id="invertBtn">Invert</button>
  <select id="presetSelect">
    <option value="">Presets...</option>
    <option value="checker">Checkerboard</option>
    <option value="cross">Cross</option>
    <option value="border">Border</option>
    <option value="heart">Heart</option>
  </select>
</div>

<div class="matrix-container">
  <div>
    <h3>Matrix 1</h3>
    <canvas id="matrix1" width="160" height="160" title="Click cells to color"></canvas>
  </div>
  <div>
    <h3>Matrix 2</h3>
    <canvas id="matrix2" width="160" height="160" title="Click cells to color"></canvas>
  </div>
</div>

<div class="grid-buttons">
  <label>Frame Delay (ms): <input type="number" id="delayInput" min="10" max="5000" value="200"></label>
  <button id="addFrameBtn">Add Frame</button>
  <button id="playPreviewBtn">Play Preview</button>
  <button id="stopPreviewBtn">Stop Preview</button>
  <button id="sendFrameBtn">Send Frame</button>
</div>

<div class="frameList">
  <h3>Frames:</h3>
  <ul id="frames"></ul>
  <div>
    <button id="moveUpBtn">Move Up</button>
    <button id="moveDownBtn">Move Down</button>
    <button id="duplicateBtn">Duplicate</button>
    <button id="reverseBtn">Reverse</button>
    <button id="deleteBtn">Delete</button>
  </div>
</div>

<div class="device">
  <h3>ESP8266 Device Control</h3>
  <div class="device-control">
    <div>
      <label>Matrix 1 IP: <input type="text" id="espIp1" value="192.168.1.100"></label>
      <button id="testConnectionBtn1">Test Connection</button>
    </div>
    <div>
      <label>Matrix 2 IP: <input type="text" id="espIp2" value="192.168.1.101"></label>
      <button id="testConnectionBtn2">Test Connection</button>
    </div>
  </div>
  <div style="text-align: center; margin-top: 10px;">
    <button id="sendAnimationBtn">Send Animation to Both</button>
    <button id="stopAnimationBtn">Stop Animation</button>
    <button id="clearMatrixBtn">Clear Both Matrices</button>
    <label>Brightness: <input type="range" id="brightness" min="1" max="255" value="100"></label>
  </div>
</div>

<div>
  <button id="saveBtn">Save Animation</button>
  <input type="file" id="loadFile" accept=".json" style="display:none" />
  <button id="loadBtn">Load Animation</button>
  <button id="undoBtn">Undo</button>
  <button id="redoBtn">Redo</button>
  <button id="toggleGridBtn">Toggle Grid</button>
</div>

<div id="status">Ready.</div>

<script>
(() => {
  // Initialize variables
  const canvas1 = document.getElementById('matrix1');
  const ctx1 = canvas1.getContext('2d');
  const canvas2 = document.getElementById('matrix2');
  const ctx2 = canvas2.getContext('2d');
  const gridSize = 8;
  const cellSize = 20;
  let grid1 = new Array(gridSize * gridSize).fill("#000000");
  let grid2 = new Array(gridSize * gridSize).fill("#000000");
  let currentColor = document.getElementById('colorPicker').value;
  let frames = [];
  let selectedFrameIndex = -1;
  let previewTimer = null;
  let previewIndex = 0;
  let history = [{grid1: [...grid1], grid2: [...grid2]}];
  let historyIndex = 0;
  let showGrid = true;
  let activeCanvas = 'matrix1'; // Track which matrix is being edited

  // Initialize grid drawing
  function drawGrid() {
    ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
    ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
    
    for(let y=0; y<gridSize; y++) {
      for(let x=0; x<gridSize; x++) {
        const idx = y * gridSize + x;
        
        // Draw matrix 1
        ctx1.fillStyle = grid1[idx];
        ctx1.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
        ctx1.strokeStyle = showGrid ? "#444" : "transparent";
        ctx1.strokeRect(x*cellSize, y*cellSize, cellSize, cellSize);
        
        // Draw matrix 2
        ctx2.fillStyle = grid2[idx];
        ctx2.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
        ctx2.strokeStyle = showGrid ? "#444" : "transparent";
        ctx2.strokeRect(x*cellSize, y*cellSize, cellSize, cellSize);
      }
    }
    
    // Highlight active canvas
    canvas1.style.border = activeCanvas === 'matrix1' ? '2px solid #007bff' : '1px solid #aaa';
    canvas2.style.border = activeCanvas === 'matrix2' ? '2px solid #007bff' : '1px solid #aaa';
  }

  // Save current state to history
  function saveState() {
    history = history.slice(0, historyIndex + 1);
    history.push({grid1: [...grid1], grid2: [...grid2]});
    historyIndex++;
  }

  // Mouse interaction handlers
  function getCellFromMouse(e, canvas) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / cellSize);
    const y = Math.floor((e.clientY - rect.top) / cellSize);
    if(x >= 0 && x < gridSize && y >= 0 && y < gridSize) return y * gridSize + x;
    return -1;
  }

  let drawing = false;
  
  function setupCanvasEvents(canvas, gridRef) {
    canvas.addEventListener('mousedown', e => {
      activeCanvas = canvas.id;
      drawing = true;
      const idx = getCellFromMouse(e, canvas);
      if(idx !== -1) {
        saveState();
        gridRef[idx] = currentColor;
        drawGrid();
      }
    });

    canvas.addEventListener('mousemove', e => {
      if(!drawing || canvas.id !== activeCanvas) return;
      const idx = getCellFromMouse(e, canvas);
      if(idx !== -1) {
        gridRef[idx] = currentColor;
        drawGrid();
      }
    });

    canvas.addEventListener('mouseup', e => drawing = false);
    canvas.addEventListener('mouseleave', e => drawing = false);
  }

  setupCanvasEvents(canvas1, grid1);
  setupCanvasEvents(canvas2, grid2);

  // Touch support for mobile devices
  function handleTouch(e, canvas) {
    e.preventDefault();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent(
      e.type === 'touchstart' ? 'mousedown' : 'mousemove',
      { clientX: touch.clientX, clientY: touch.clientY }
    );
    canvas.dispatchEvent(mouseEvent);
  }
  
  canvas1.addEventListener('touchstart', (e) => handleTouch(e, canvas1));
  canvas1.addEventListener('touchmove', (e) => handleTouch(e, canvas1));
  canvas2.addEventListener('touchstart', (e) => handleTouch(e, canvas2));
  canvas2.addEventListener('touchmove', (e) => handleTouch(e, canvas2));

  // Color picker and grid manipulation
  document.getElementById('colorPicker').addEventListener('input', e => {
    currentColor = e.target.value;
  });

  document.getElementById('clearBtn').addEventListener('click', () => {
    saveState();
    if(activeCanvas === 'matrix1') grid1.fill("#000000");
    else grid2.fill("#000000");
    drawGrid();
  });

  document.getElementById('randomBtn').addEventListener('click', () => {
    saveState();
    const grid = activeCanvas === 'matrix1' ? grid1 : grid2;
    for(let i=0; i<grid.length; i++) {
      grid[i] = '#' + Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
    }
    drawGrid();
  });

  document.getElementById('invertBtn').addEventListener('click', () => {
    saveState();
    const grid = activeCanvas === 'matrix1' ? grid1 : grid2;
    for(let i=0; i<grid.length; i++) {
      const c = grid[i];
      let r = 255 - parseInt(c.slice(1,3),16);
      let g = 255 - parseInt(c.slice(3,5),16);
      let b = 255 - parseInt(c.slice(5,7),16);
      grid[i] = `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
    }
    drawGrid();
  });

  // Preset patterns
  document.getElementById('presetSelect').addEventListener('change', (e) => {
    const pattern = e.target.value;
    if(!pattern) return;
    saveState();
    
    const grid = activeCanvas === 'matrix1' ? grid1 : grid2;
    
    switch(pattern) {
      case 'checker':
        for(let i=0; i<grid.length; i++) {
          grid[i] = (Math.floor(i/8)+i)%2 ? '#FF0000' : '#000000';
        }
        break;
      case 'cross':
        for(let i=0; i<grid.length; i++) {
          const x = i%8, y = Math.floor(i/8);
          grid[i] = (x === y || x === 7-y) ? '#00FF00' : '#000000';
        }
        break;
      case 'border':
        for(let i=0; i<grid.length; i++) {
          const x = i%8, y = Math.floor(i/8);
          grid[i] = (x === 0 || x === 7 || y === 0 || y === 7) ? '#0000FF' : '#000000';
        }
        break;
      case 'heart':
        const heartPattern = [
          0,0,0,0,0,0,0,0,
          0,1,1,0,0,1,1,0,
          1,1,1,1,1,1,1,1,
          1,1,1,1,1,1,1,1,
          0,1,1,1,1,1,1,0,
          0,0,1,1,1,1,0,0,
          0,0,0,1,1,0,0,0,
          0,0,0,0,0,0,0,0
        ];
        for(let i=0; i<grid.length; i++) {
          grid[i] = heartPattern[i] ? '#FF0000' : '#000000';
        }
        break;
    }
    drawGrid();
    e.target.value = '';
  });

  // Frame management
  const frameList = document.getElementById('frames');
  function updateFrameList() {
    frameList.innerHTML = '';
    frames.forEach((f, i) => {
      const li = document.createElement('li');
      li.innerHTML = `<span>Frame ${i+1} (Delay: ${f.delay}ms)</span>`;
      li.style.cursor = 'pointer';
      li.style.backgroundColor = (i === selectedFrameIndex) ? '#d0e6ff' : '';
      li.onclick = () => loadFrame(i);
      frameList.appendChild(li);
    });
  }

  document.getElementById('addFrameBtn').addEventListener('click', () => {
    const delay = parseInt(document.getElementById('delayInput').value) || 200;
    frames.push({
      delay,
      colors1: [...grid1],
      colors2: [...grid2]
    });
    selectedFrameIndex = frames.length - 1;
    updateFrameList();
    setStatus(`Added frame ${frames.length} with delay ${delay}ms`);
  });

  function loadFrame(i) {
    if(i < 0 || i >= frames.length) return;
    grid1 = [...frames[i].colors1];
    grid2 = [...frames[i].colors2];
    document.getElementById('delayInput').value = frames[i].delay;
    selectedFrameIndex = i;
    drawGrid();
    updateFrameList();
    setStatus(`Loaded frame ${i+1}`);
  }

  document.getElementById('deleteBtn').addEventListener('click', () => {
    if(selectedFrameIndex < 0) return;
    frames.splice(selectedFrameIndex, 1);
    if(selectedFrameIndex >= frames.length) selectedFrameIndex = frames.length - 1;
    if(selectedFrameIndex >= 0) loadFrame(selectedFrameIndex);
    else {
      grid1.fill("#000000");
      grid2.fill("#000000");
      drawGrid();
      updateFrameList();
      setStatus('All frames deleted');
    }
  });

  document.getElementById('duplicateBtn').addEventListener('click', () => {
    if(selectedFrameIndex < 0) return;
    const copy = JSON.parse(JSON.stringify(frames[selectedFrameIndex]));
    frames.splice(selectedFrameIndex + 1, 0, copy);
    updateFrameList();
    setStatus(`Duplicated frame ${selectedFrameIndex + 1}`);
  });

  document.getElementById('moveUpBtn').addEventListener('click', () => {
    if(selectedFrameIndex <= 0) return;
    [frames[selectedFrameIndex-1], frames[selectedFrameIndex]] = [frames[selectedFrameIndex], frames[selectedFrameIndex-1]];
    selectedFrameIndex--;
    updateFrameList();
    loadFrame(selectedFrameIndex);
  });

  document.getElementById('moveDownBtn').addEventListener('click', () => {
    if(selectedFrameIndex < 0 || selectedFrameIndex >= frames.length - 1) return;
    [frames[selectedFrameIndex], frames[selectedFrameIndex+1]] = [frames[selectedFrameIndex+1], frames[selectedFrameIndex]];
    selectedFrameIndex++;
    updateFrameList();
    loadFrame(selectedFrameIndex);
  });

  document.getElementById('reverseBtn').addEventListener('click', () => {
    frames.reverse();
    updateFrameList();
    setStatus('Reversed animation');
  });

  // Animation preview
  document.getElementById('playPreviewBtn').addEventListener('click', () => {
    if(frames.length === 0) return;
    if(previewTimer) clearInterval(previewTimer);
    previewIndex = 0;
    previewTimer = setInterval(() => {
      loadFrame(previewIndex);
      previewIndex = (previewIndex + 1) % frames.length;
    }, frames[previewIndex].delay);
    setStatus('Preview started');
  });

  document.getElementById('stopPreviewBtn').addEventListener('click', () => {
    if(previewTimer) {
      clearInterval(previewTimer);
      previewTimer = null;
      setStatus('Preview stopped');
      if(selectedFrameIndex >= 0) loadFrame(selectedFrameIndex);
      else drawGrid();
    }
  });

  // Undo/Redo functionality
  document.getElementById('undoBtn').addEventListener('click', () => {
    if(historyIndex > 0) {
      historyIndex--;
      grid1 = [...history[historyIndex].grid1];
      grid2 = [...history[historyIndex].grid2];
      drawGrid();
    }
  });

  document.getElementById('redoBtn').addEventListener('click', () => {
    if(historyIndex < history.length - 1) {
      historyIndex++;
      grid1 = [...history[historyIndex].grid1];
      grid2 = [...history[historyIndex].grid2];
      drawGrid();
    }
  });

  // Toggle grid visibility
  document.getElementById('toggleGridBtn').addEventListener('click', () => {
    showGrid = !showGrid;
    drawGrid();
  });

  // ESP8266 communication
  function gridToESPFormat(colors) {
    return colors.map(c => {
      const r = parseInt(c.slice(1,3),16);
      const g = parseInt(c.slice(3,5),16);
      const b = parseInt(c.slice(5,7),16);
      return `${r},${g},${b}`;
    }).join(';');
  }

  async function sendESPCommand(ip, command, data=null) {
    if(!ip) {
      setStatus('Please enter ESP IP address');
      return false;
    }
    let url = `http://${ip}/${command}`;
    if(data) url += `?data=${encodeURIComponent(data)}`;
    try {
      const res = await fetch(url);
      const text = await res.text();
      setStatus(`ESP ${ip} Response: ${text}`);
      return true;
    } catch(e) {
      setStatus(`Error (${ip}): ${e.message}`);
      return false;
    }
  }

  document.getElementById('sendFrameBtn').addEventListener('click', async () => {
    const ip1 = document.getElementById('espIp1').value.trim();
    const ip2 = document.getElementById('espIp2').value.trim();
    
    if(selectedFrameIndex >= 0 && frames[selectedFrameIndex]) {
      const espData1 = gridToESPFormat(frames[selectedFrameIndex].colors1);
      const espData2 = gridToESPFormat(frames[selectedFrameIndex].colors2);
      await Promise.all([
        sendESPCommand(ip1, 'setFrame', espData1),
        sendESPCommand(ip2, 'setFrame', espData2)
      ]);
    } else {
      const espData1 = gridToESPFormat(grid1);
      const espData2 = gridToESPFormat(grid2);
      await Promise.all([
        sendESPCommand(ip1, 'setFrame', espData1),
        sendESPCommand(ip2, 'setFrame', espData2)
      ]);
    }
  });

  document.getElementById('testConnectionBtn1').addEventListener('click', async () => {
    const ip = document.getElementById('espIp1').value.trim();
    await sendESPCommand(ip, 'ping');
  });

  document.getElementById('testConnectionBtn2').addEventListener('click', async () => {
    const ip = document.getElementById('espIp2').value.trim();
    await sendESPCommand(ip, 'ping');
  });

  document.getElementById('sendAnimationBtn').addEventListener('click', async () => {
    if(frames.length === 0) return;
    
    const ip1 = document.getElementById('espIp1').value.trim();
    const ip2 = document.getElementById('espIp2').value.trim();
    
    const animation1 = frames.map(f => ({
      delay: f.delay,
      colors: gridToESPFormat(f.colors1)
    }));
    
    const animation2 = frames.map(f => ({
      delay: f.delay,
      colors: gridToESPFormat(f.colors2)
    }));
    
    await Promise.all([
      sendESPCommand(ip1, 'setAnimation', JSON.stringify(animation1)),
      sendESPCommand(ip2, 'setAnimation', JSON.stringify(animation2))
    ]);
    
    await Promise.all([
      sendESPCommand(ip1, 'startAnimation'),
      sendESPCommand(ip2, 'startAnimation')
    ]);
  });

  document.getElementById('stopAnimationBtn').addEventListener('click', async () => {
    const ip1 = document.getElementById('espIp1').value.trim();
    const ip2 = document.getElementById('espIp2').value.trim();
    await Promise.all([
      sendESPCommand(ip1, 'stopAnimation'),
      sendESPCommand(ip2, 'stopAnimation')
    ]);
  });

  document.getElementById('clearMatrixBtn').addEventListener('click', async () => {
    const ip1 = document.getElementById('espIp1').value.trim();
    const ip2 = document.getElementById('espIp2').value.trim();
    await Promise.all([
      sendESPCommand(ip1, 'clear'),
      sendESPCommand(ip2, 'clear')
    ]);
  });

  document.getElementById('brightness').addEventListener('input', async e => {
    const ip1 = document.getElementById('espIp1').value.trim();
    const ip2 = document.getElementById('espIp2').value.trim();
    await Promise.all([
      sendESPCommand(ip1, 'setBrightness', e.target.value),
      sendESPCommand(ip2, 'setBrightness', e.target.value)
    ]);
  });

  // Save/Load functionality
  document.getElementById('saveBtn').addEventListener('click', () => {
    if(frames.length === 0) return;
    const data = {
      frames: frames,
      created: new Date().toISOString(),
      version: "1.0"
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `led_animation_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    setStatus('Animation saved to file');
  });

  document.getElementById('loadBtn').addEventListener('click', () => {
    document.getElementById('loadFile').click();
  });

  document.getElementById('loadFile').addEventListener('change', e => {
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = evt => {
      try {
        const json = JSON.parse(evt.target.result);
        if(!json.frames || !Array.isArray(json.frames)) throw new Error('Invalid file');
        frames = json.frames;
        if(frames.length > 0) loadFrame(0);
        updateFrameList();
        setStatus(`Loaded ${frames.length} frames`);
      } catch(err) {
        setStatus('Error loading file: ' + err.message);
      }
    };
    reader.readAsText(file);
  });

  // Status message helper
  function setStatus(msg) {
    document.getElementById('status').textContent = msg;
  }

  // Initialize
  drawGrid();
  setStatus('Ready.');
})();
</script>
</body>
</html>