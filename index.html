<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>9×6 Pixel-Ring Scheduler – 40 px Edition (TXT Save)</title>
  <style>
    :root {
      --bg: #0f0f23;
      --led-off: #222;
      --led-on: #0f0;
      --font: "Courier New", monospace;
      --size: 40px;
    }

    body {
      margin: 0;
      font-family: var(--font);
      background: var(--bg);
      color: var(--led-on);
      text-align: center;
      padding: 20px;
    }

    #ledRing {
      position: relative;
      width: 600px;
      height: 600px;
      margin: 20px auto;
      image-rendering: pixelated;
    }

    .led {
      position: absolute;
      width: var(--size);
      height: var(--size);
      background: var(--led-off);
      border: 2px solid #000;
      cursor: pointer;
      transition: transform 0.2s;
    }

    @keyframes pump {
      50% { transform: scale(1.15); }
    }

    .led.on {
      background: var(--led-on);
      animation: pump 0.2s ease;
    }

    button, input {
      margin: 8px;
      padding: 4px 8px;
      font-family: var(--font);
      background: #111;
      color: var(--led-on);
      border: 1px solid var(--led-on);
    }

    button:hover {
      background: var(--led-on);
      color: #000;
    }

    #outputWrapper {
      position: relative;
      max-width: 500px;
      margin: 20px auto;
    }

    #lastLine {
      background: #111;
      color: var(--led-on);
      padding: 4px 8px;
      font-family: var(--font);
      text-align: left;
      font-size: 14px;
      white-space: pre;
      border: 1px solid #000;
    }

    #fullOutput {
      display: none;
      background: #111;
      color: var(--led-on);
      padding: 10px;
      overflow-x: auto;
      border: 1px solid #000;
      margin-top: 4px;
    }

    #pwBox { margin: 8px; }
  </style>
</head>

<body>
  <h2>9×6 Pixel-Ring Scheduler – 40 px Edition (TXT Save)</h2>

  <!-- ====== Controls ====== -->
  <button onclick="addDuration()">➕ Add Duration</button>
  <button onclick="undoLast()">⏪ Undo Last Duration</button>
  <button onclick="backDuration()">🡐 Back Duration</button>
  <button onclick="backDurationSave()">🔙 Back Duration Save</button>
  <button onclick="goLastDuration()">➡️ Go Last Duration</button>
  <button onclick="changeBaseTime()">⚙️ Change Base-Time (ms)</button>
  <button onclick="moveColors(true)">➡️ Rotate CW</button>
  <button onclick="moveColors(false)">⤴︎ Rotate CCW</button>
  <button onclick="rotateLineByLine(true)">🔃 Rotate CW (Line-by-Line)</button>
  <button onclick="rotateLineByLine(false)">🔄 Rotate CCW (Line-by-Line)</button>
  <button onclick="clearAllColors()">🧹 Clear All Colors</button>
  <button onclick="repeatPattern()">🔁 Repeat Pattern</button>
  <button onclick="previewAnimation()">🔄 Animate Preview</button>
  <button onclick="saveSchedule()">💾 Save Schedule (txt)</button>

  <!-- NEW COLUMN SHIFT BUTTONS -->
  <button onclick="shiftColUp()">🔼 Shift Col ↑</button>
  <button onclick="shiftColDown()">🔽 Shift Col ↓</button>

  <input type="file" onchange="loadSchedule(this)" accept=".txt" style="margin:0 8px;">
  <input type="file" id="folderInput" multiple accept=".txt" onchange="loadFolderLoop(this)" style="display:none">
  <button onclick="document.getElementById('folderInput').click()">📁 Load Folder (Loop)</button>

  <div id="ledRing"></div>

  <label>Pick Colour: <input type="color" id="colorPicker" value="#00ff00"></label><br>
  <label>ON Duration (ms): <input type="number" id="duration" value="5000" min="100"></label><br>

  <!-- ====== Password-protected output ====== -->
  <div id="outputWrapper">
    <div id="lastLine"></div>
    <div id="pwBox">
      <input id="password" type="password" placeholder="Enter password" />
      <button onclick="unlockOutput()">Unlock</button>
    </div>
    <pre id="fullOutput"></pre>
  </div>

  <script>
    const rays = 9;
    const ledsPerRay = 6;
    const radiusStep = 50;
    const centerX = 300;
    const centerY = 300;
    const totalLEDs = rays * ledsPerRay;
    let baseTime = 60000;
    let currentTime = baseTime;
    let schedule = [];
    const prevStates = [];
    const colorHistory = [];
    const timeHistory = [];

    const ledRing = document.getElementById('ledRing');
    const colorPicker = document.getElementById('colorPicker');
    const leds = [];

    const mapIndex = (i) => (i + totalLEDs - 18) % totalLEDs;

    /* ---------- LED creation ---------- */
    for (let r = 0; r < rays; r++) {
      const angle = (r / rays) * 2 * Math.PI;
      for (let i = 0; i < ledsPerRay; i++) {
        const originalIndex = i + (r * ledsPerRay);
        const index = mapIndex(originalIndex);
        const radius = radiusStep * (i + 1);
        const x = centerX + radius * Math.cos(angle) - 20;
        const y = centerY + radius * Math.sin(angle) - 20;

        const led = document.createElement('div');
        led.className = 'led';
        led.style.left = `${x}px`;
        led.style.top = `${y}px`;
        led.dataset.index = index;
        led.dataset.color = '';

        led.onclick = () => {
          const hex = colorPicker.value;
          led.style.backgroundColor = hex;
          led.dataset.color = hex;
          led.classList.add('on');
          setTimeout(() => led.classList.remove('on'), 200);
        };

        leds.push(led);
        ledRing.appendChild(led);
      }
    }

    /* ---------- core helpers ---------- */
    function renderOutput() {
      const outLines = schedule.map(e => `${e.led},${e.start},${e.end},${e.color}`);
      const fullText = `# total duration ${currentTime - baseTime} ms\n${outLines.join('\n')}`;
      document.getElementById('fullOutput').textContent = fullText;

      const last = schedule[schedule.length - 1];
      document.getElementById('lastLine').textContent = last ? `*,*,${last.end},*` : '(hidden)';
    }

    function changeBaseTime() {
      const newBase = prompt('Enter new base-time in milliseconds (current: ' + baseTime + '):');
      if (newBase === null) return;
      const n = parseInt(newBase, 10);
      if (isNaN(n) || n < 0) { alert('Valid positive number required'); return; }
      const delta = n - baseTime;
      schedule.forEach(e => { e.start += delta; e.end += delta; });
      baseTime = n; currentTime += delta;
      renderOutput();
    }

    function addDuration(pushHistory = true) {
      const duration = parseInt(document.getElementById('duration').value);
      const endTime = currentTime + duration;
      const newEntries = [];
      const currentColors = leds.map(led => led.dataset.color || '');

      if (pushHistory) {
        colorHistory.push(currentColors);
        timeHistory.push(currentTime);
      }

      leds.forEach((led) => {
        const color = led.dataset.color;
        if (color && color !== '') {
          const hex = color.replace('#', '').toLowerCase();
          newEntries.push({
            led: parseInt(led.dataset.index),
            start: currentTime,
            end: endTime,
            color: hex
          });
        }
      });

      if (newEntries.length > 0) {
        prevStates.push([...schedule]);
        schedule.push(...newEntries);
        currentTime = endTime;
        renderOutput();
      }
    }

    function backDuration() {
      if (colorHistory.length === 0 || timeHistory.length === 0) return;
      const lastColors = colorHistory.pop();
      currentTime = timeHistory.pop();
      leds.forEach((led, i) => {
        led.dataset.color = lastColors[i];
        led.style.backgroundColor = lastColors[i] || 'var(--led-off)';
      });
      renderOutput();
    }

    function backDurationSave() {
      if (colorHistory.length === 0 || timeHistory.length === 0) return;
      backDuration();
      const startTimeToRemove = currentTime;
      const currentColors = leds.map(led => led.dataset.color || '');
      const originalBlock = schedule.filter(e => e.start === startTimeToRemove);
      const modified = originalBlock.some(e => {
        const current = currentColors[e.led]?.replace('#', '').toLowerCase() || '';
        return current !== e.color;
      });
      if (!modified) { console.log("No color changes to save."); return; }
      schedule = schedule.filter(e => e.start !== startTimeToRemove);
      addDuration(false);
    }

    function goLastDuration() {
      if (!schedule.length) return;
      const lastEnd = Math.max(...schedule.map(e => e.end));
      const startOfLastBlock = Math.max(...schedule.map(e => e.start));
      currentTime = lastEnd;
      const currentColors = leds.map(led => led.dataset.color || '');
      colorHistory.push(currentColors);
      timeHistory.push(startOfLastBlock);
      clearAllColors();
      schedule.filter(e => e.start === startOfLastBlock).forEach(e=>{
        const led=leds.find(l=>+l.dataset.index===e.led);
        if(led){led.dataset.color=`#${e.color}`;led.style.backgroundColor=`#${e.color}`;}
      });
      renderOutput();
    }

    function undoLast() {
      if (prevStates.length > 0) { schedule = prevStates.pop(); renderOutput(); }
    }

    function clearAllColors() {
      leds.forEach(led => { led.dataset.color = ''; led.style.backgroundColor = 'var(--led-off)'; });
    }

    function moveColors(dir = true) {
      const colors = leds.map(l => l.dataset.color || '');
      const bgs = leds.map(l => l.style.backgroundColor);
      if (dir) { colors.unshift(colors.pop()); bgs.unshift(bgs.pop()); }
      else     { colors.push(colors.shift());  bgs.push(bgs.shift());  }
      colors.forEach((c, i) => { leds[i].dataset.color = c; leds[i].style.backgroundColor = bgs[i]; });
    }

    function rotateLineByLine(dir = true) {
      for (let i = 0; i < ledsPerRay; i++) {
        const lineLEDs = [], lineBGs = [];
        for (let r = 0; r < rays; r++) {
          const idx = mapIndex(i + r * ledsPerRay);
          lineLEDs.push(leds[idx].dataset.color || '');
          lineBGs.push(leds[idx].style.backgroundColor);
        }
        if (dir) { lineLEDs.unshift(lineLEDs.pop()); lineBGs.unshift(lineBGs.pop()); }
        else     { lineLEDs.push(lineLEDs.shift());  lineBGs.push(lineBGs.shift());  }
        for (let r = 0; r < rays; r++) {
          const idx = mapIndex(i + r * ledsPerRay);
          leds[idx].dataset.color = lineLEDs[r];
          leds[idx].style.backgroundColor = lineBGs[r];
        }
      }
    }

    /* ---------- NEW COLUMN SHIFT HELPERS ---------- */
    function shiftColUp()   { shiftCol(true);  }
    function shiftColDown() { shiftCol(false); }

    function shiftCol(up = true) {
      // one column = one ray => 6 LEDs
      for (let r = 0; r < rays; r++) {
        const colLEDs = [], colBGs = [];
        for (let i = 0; i < ledsPerRay; i++) {
          const idx = mapIndex(i + r * ledsPerRay);
          colLEDs.push(leds[idx].dataset.color || '');
          colBGs.push(leds[idx].style.backgroundColor);
        }
        if (up) { colLEDs.push(colLEDs.shift());  colBGs.push(colBGs.shift());  }   // up
        else    { colLEDs.unshift(colLEDs.pop()); colBGs.unshift(colBGs.pop()); }   // down
        for (let i = 0; i < ledsPerRay; i++) {
          const idx = mapIndex(i + r * ledsPerRay);
          leds[idx].dataset.color = colLEDs[i];
          leds[idx].style.backgroundColor = colBGs[i];
        }
      }
    }

    /* ---------- schedule helpers ---------- */
    function repeatPattern() {
      const previous = schedule.filter(e => e.start >= baseTime);
      if (previous.length === 0) return;
      const delta = currentTime - baseTime;
      const repeated = previous.map(e => ({
        led: e.led,
        start: e.start + delta,
        end: e.end + delta,
        color: e.color
      }));
      prevStates.push([...schedule]);
      schedule.push(...repeated);
      currentTime += delta;
      renderOutput();
    }

    function previewAnimation() {
      const ledsMap = {};
      schedule.forEach(e => {
        if (!ledsMap[e.start]) ledsMap[e.start] = [];
        ledsMap[e.start].push(e);
      });
      const times = Object.keys(ledsMap).map(t => parseInt(t)).sort((a, b) => a - b);
      function applyFrame(i) {
        if (i >= times.length) return;
        clearAllColors();
        ledsMap[times[i]].forEach(e => {
          const led = leds.find(l => parseInt(l.dataset.index) === e.led);
          if (led) {
            led.style.backgroundColor = `#${e.color}`;
            led.dataset.color = `#${e.color}`;
          }
        });
        setTimeout(() => applyFrame(i + 1), 500);
      }
      applyFrame(0);
    }

    /* ---------- TEXT SAVE ---------- */
    function saveSchedule () {
      const lines  = schedule.map(e => `${e.led},${e.start},${e.end},${e.color}`);
      const text   = `# total duration ${currentTime - baseTime} ms\n${lines.join('\n')}`;
      downloadText(text, 'schedules.txt');
    }

    function downloadText (content, filename) {
      const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
      const a    = document.createElement('a');
      a.href     = URL.createObjectURL(blob);
      a.download = filename;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
    }

    function loadSchedule(input) {
      const file = input.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (e) {
        const lines = e.target.result.split('\n').filter(line => line.trim() && !line.startsWith('#'));
        schedule = [];
        currentTime = baseTime;
        lines.forEach(line => {
          const [led, start, end, color] = line.split(',');
          schedule.push({ led: parseInt(led), start: parseInt(start), end: parseInt(end), color });
          currentTime = Math.max(currentTime, parseInt(end));
        });
        renderOutput();
      };
      reader.readAsText(file);
    }

    /* ---------- password unlock ---------- */
    function unlockOutput() {
      const pw = document.getElementById('password').value;
      if (pw === '0000') {
        document.getElementById('fullOutput').style.display = 'block';
        document.getElementById('pwBox').style.display = 'none';
      } else {
        alert('Wrong password.');
      }
    }

    /* initial render */
    renderOutput();
  </script>
</body>
</html>
